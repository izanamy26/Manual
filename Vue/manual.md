# Vue <a name='home'></a> 
<a href="https://ru.vuejs.org/">https://ru.vuejs.org/</a>   
<a href="https://ru.vuejs.org/v2/api/">Актуальное API</a>

***
* [Компоненты](#components)
* [Входные параметры](#params)
* [Модификаторы](#modifycators)
* [Директивы](#directives)
* [Специальные аттрибуты](#spec-attr)
* [Вычисляемые свойства](#computed)
* [Наблюдатели](#watch)
* [Стили](#styles)
* [Отрисовка списков](#for)
* [Обработка событий](#event)
* [Шина событий](#event-bus)
* [Пользовательские события](#users-event)
* [Слоты](#slot)
* [Динамические и асинхронные компоненты](#dinamyc)
* [Исключения, обработка ошибок](#exseption)
* [Примеси](#mixin)
* [Пользовательские директивы](#user-directive)
* [Render-функции и JSX](#render-jsx)
* [Функциональный компонент](#functional)
* [Плагины](#plugins)
* [Фильтры](#filters)
* [Vuex](#vuex)
* [Vue-router](#router)
* [Vue-cli](#cli)
* [Тестирование](#test)
* [vue-class-component](#vue-class-component)


***
VueJS представляет CLI для установки vue и начала работы с активацией сервера. 
* npm install --global vue-cli

***
 Создания проекта с использованием Webpack
* vue init webpack myproject

***
Запуск
* cd myproject
* npm run dev

***
[^ Вверх](#home)  


# Компоненты <a name="components"></a>

```javascript
// Определяем новый компонент под именем todo-item
Vue.component('todo-item', {
  template: '<li>Это одна задача в списке</li>'
})
```
Теперь его можно использовать в шаблоне другого компонента:

```html
<ol>
  <!-- Создаём экземпляр компонента todo-item -->
  <todo-item></todo-item>
</ol>
```
Когда экземпляр Vue создан, он добавляет все свойства, найденные в опции data, в систему реактивности Vue. Но! Свойства в data будут реактивными, только если они существовали при создании экземпляра. Т.е. необходимо сразу установить начальное значение.

Каждый экземпляр Vue при создании проходит через последовательность шагов инициализации :
1) настраивается наблюдение за данными;
2) компилируется шаблон;
3) монтируется экземпляр в DOM;
4) обновляется DOM при изменении данных.

<img alt='Жизненный цикл компанента' src="manual/images/life.png"/>



[^ Вверх](#home)  
# Входные параметры <a name='params'></a>
При использовании шаблонов в DOM входные параметры в camelCase-стиле в компоненте должны использовать свои эквиваленты в стиле kebab-case (разделённые дефисами).

Указание типа входных параметров:
```javascript
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // или любой другой конструктор
}
```
Для того, чтобы указать Vue, что передается выражение, а не строка, необходимо использовать ```v-bind:```. Это относится к числам, булевым значениям, массивам, объектам.

```html
<!-- Указание входного параметра без значения будет означать `true`. -->
<blog-post is-published></blog-post>

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.     -->
<blog-post v-bind:is-published="false"></blog-post>
```

Все входные параметры образуют одностороннюю привязку между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Изменение входного параметра может потребоваться в нескольких случая:

1. Входной параметр используется для передачи начального значения. В этом случае лучше всего определить локальное свойство в данных, которое использует значение входного параметра в качестве начального:
```javascript
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```
2. Входной параметр передаётся как необработанное значение, которое необходимо преобразовать. В этом случае лучше всего определить вычисляемое свойство с использованием входного параметра:

```javascript
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```
> Но! Объекты и массивы передаются по ссылке, поэтому изменение в дочернем элементе повлияет на данные родительского. В данном случае необходимо сделать копию, например, с помощью reduce или $.extend.

Валидация входных параметров:
```javascript
Vue.component('my-component', {
  props: {
    // Просто проверка типа (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propE: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции
      default: function () {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для валидации
    propF: {
      validator: function (value) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```
>  Входные параметры валидируются перед созданием экземпляра компонента, поэтому свойства экземпляра (например, data, computed и т.д.) не будут доступны внутри default или функций validator.

Отключить наследование атрибутов можно с помощью 
```javascript
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```
 Cвойство экземпляра ```$attrs``` содержит имена атрибутов и значения, переданные компоненту.
 Опция ```inheritAttrs: false``` не влияет на биндинги style и class.

С помощью ```inheritAttrs: false``` и ```$attrs``` можно вручную определять к какому элементу должны применяться атрибуты, что часто требуется для базовых компонентов:

```javascript
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```

[^ Вверх](#home)  







# Модификаторы <a name='modifycators'></a>

Модификаторы — особые постфиксы, добавляемые после точки, обозначающие, что директива должна быть связана каким-то определённым образом.  

```html
<!-- модификатор .prevent говорит директиве v-on вызвать event.preventDefault() при обработке произошедшего события -->
<form v-on:submit.prevent="onSubmit"> ... </form>
```
  
[^ Вверх](#home)  







# Директивы <a name="directives"></a>

Директивы — это специальные атрибуты с префиксом ```v-```. В качестве значения они принимают одно выражение JavaScript (за исключением v-for). Директива реактивно применяет к DOM изменения при обновлении значения этого выражения. 

Начиная с версии 2.6.0, можно использовать JavaScript-выражение в аргументе директивы, заключив его в квадратные скобки:

```html
<a v-bind:[attributeName]="url"> ... </a>
```

## v-text<a name='v-text'></a> 
Управляет текстовым содержимым, тоже что и интерполяция ```{{ Mustache }}```.
```html
<span v-text="msg"></span>
<!-- то же, что -->
<span>{{msg}}</span>
```
***
## v-html<a name='v-html'></a> 
Управляет HTML-содержимым элемента (innerHTML), т.е. содержимое вставляется как обычный HTML, но при этом не компилируется как шаблон Vue. 
```html
<p>Двойные фигурные скобки: {{ rawHtml }}</p>
<p>Директива v-html: <span v-html="rawHtml"></span></p>
```
Содержимое тега *span* будет заменено значением свойства *rawHtml*, интерпретированного как обычный HTML.  Нельзя использовать ```v-html``` для вложения шаблонов друг в друга, потому что движок шаблонов Vue не основывается на строках. 

>Динамическая отрисовка произвольного HTML-кода на сайте крайне опасна, так как может легко привести к XSS-уязвимостям. Использовать интерполяцию HTML можно только для доверенного кода, и нельзя подставлять туда содержимое, создаваемое пользователями.



## v-if<a name='v-if'></a> 
Осуществляет отрисовку элемента, только если передаваемое выражение истинно. При изменении значения выражения на противоположное, элемент и содержащиеся в нём компоненты и директивы уничтожаются/пересоздаются. Т.е. если передаваемое выражение ложно, то элемент не будет вставлен в DOM. Эта директива также запускает анимационные переходы при изменении условия.    
Совместно могут использоваться директивы: ```v-if```, ```v-else-if```.
```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
```


## v-show<a name='v-show'></a> 
Переключает CSS-свойство display элемента, в зависимости от того, истинно ли указанное выражение, т.е. элемент всегда есть в DOM. При изменении состояния этой директивы вызываются анимации, заданные в transition.

## v-for<a name='v-for'></a> 
Многократно отрисовывает элемент или блок шаблона, основываясь на переданных данных.

```app4.todos.push({ text: 'Profit' })```  // добавит новый элемент в список.
```html
<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, name, index) in object"></div>
```
При обновлении Vue списка элементов, отображаемого директивой v-for, по умолчанию используется стратегия обновления «на месте». Если порядок элементов массива или объекта изменился, Vue не станет перемещать элементы DOM, а просто обновит каждый элемент «на месте», чтобы он отображал новые данные по соответствующему индексу. 
Чтобы подсказать Vue, как отслеживать идентичность каждого элемента, что позволит переиспользовать и перемещать существующие элементы, укажите уникальный атрибут [```key```](#key).


## v-on <a name='v-on'></a>
 Добавляет к элементу обработчик события. У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.
### Модификаторы:
**.stop** — вызовет event.stopPropagation().  
**.prevent** — вызовет event.preventDefault().  
**.capture** — добавит подписку в режиме capture.  
**.self** — вызовет обработчик только если событие возникло непосредственно на этом элементе.  
**.{keyCode | keyAlias}** — вызывает обработчик только при нажатии определённой клавиши.  
**.native** — подписаться на нативное событие на корневом элементе компонента.  
**.once** — вызовет обработчик не больше одного раза.  
**.left** - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.  
**.right** - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.  
**.middle** - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.  
**.passive** - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.


```html
<!-- обработчик метода -->
<button v-on:click="doThis"></button>

<!-- динамическое имя события (2.6.0+) -->
<button v-on:[event]="doThis"></button>

<!-- inline-выражение -->
<button v-on:click="doThat('hello', $event)"></button>

<!-- сокращённая запись -->
<button @click="doThis"></button>

<!-- сокращённая запись динамического имени события (2.6.0+) -->
<button @[event]="doThis"></button>

<!-- модификатор stop propagation -->
<button @click.stop="doThis"></button>

<!-- модификатор prevent default -->
<button @click.prevent="doThis"></button>

<!-- модификатор prevent default без дополнительных действий -->
<form @submit.prevent></form>

<!-- цепочка из модификаторов -->
<button @click.stop.prevent="doThis"></button>

<!-- модификатор клавиши keyAlias -->
<input @keyup.enter="onEnter">

<!-- модификатор клавиши keyCode -->
<input @keyup.13="onEnter">

<!-- обработчик метода будет вызван не больше одного раза -->
<button v-on:click.once="doThis"></button>

<!-- синтаксис объекта (2.4.0+) -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
```
Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает “my-event”):
```html
<my-component @my-event="handleThis"></my-component>

<!-- inline-выражение -->
<my-component @my-event="handleThis(123, $event)"></my-component>

<!-- подписываемся на нативное событие в компоненте -->
<my-component @click.native="onClick"></my-component>
```



## v-bind <a name='v-bind'></a>
Динамически связывает атрибуты тега или входной параметр компонента с выражением. При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений.

```html
<!-- связывание атрибута -->
<img v-bind:src="imageSrc">

<!-- динамическое имя атрибута (2.6.0+) -->
<button v-bind:[key]="value"></button>

<!-- сокращённая запись -->
<img :src="imageSrc">

<!-- сокращённая запись для динамического имени атрибута (2.6.0+) -->
<button :[key]="value"></button>

<!-- поддержка конкатенации строк -->
<img :src="'/path/to/images/' + fileName">

<!-- связывание CSS-класса -->
<div :class="{ red: isRed }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]">

<!-- связывание локального стиля -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>

<!-- связывание с объектом, содержащим атрибуты -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

<!-- связывание с атрибутами DOM при указании модификатора -->
<div v-bind:text-content.prop="text"></div>

<!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
<my-component :prop="someThing"></my-component>

<!-- передача всех входных параметров компонента в child-component -->
<child-component v-bind="$props"></child-component>

<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>
```

## v-model <a name='v-model'></a>
Двусторонним образом связывает элемент ввода данных или компонент с переменной. Используется только с ```<input>```, ```<textarea>```, ```<select>``` и компонентами.

```v-model``` игнорирует начальное значение атрибутов **value**, **checked** или **selected** на любых элементах форм. Данные экземпляра Vue всегда считаются источником истины. Начальное значение необходимо объявить на стороне JavaScript, внутри опции ```data``` компонента.

Внутренне ```v-model``` использует разные свойства и генерирует разные события для различных элементов ввода:

* элементы для ввода текста и многострочного текста используют свойство value и событие input;  
* чекбоксы и радиокнопки используют свойство checked и событие change;  
* выпадающие списки используют свойство value и событие change.

Сама директива делает тоже самое, что и:
```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```
Т.е. **value** связывается со значением, которому присваивается введенное значение по событию```input```.


### Использование на компоненте
При использовании на компоненте ```v-model``` делает следующее:

```html
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```
Чтобы это действительно работало, элемент ```<input>``` внутри компонента должен:

* Привязывать значение атрибута **value** к входному параметру **value**;  
* По событию **input** генерировать собственное пользовательское событие **input** с новым значением; 

```html
 <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
```
теперь v-model будет прекрасно работать с этим компонентом:

```html
<custom-input v-model="searchText"></custom-input>
```

### Модификаторы:
**.lazy** — подписаться на события change, а не input.  
**.number** — приводить корректную введённую строку к числу.  
**.trim** — удалять пробелы в начале и в конце введённой строки.


## v-slot <a name='v-slot'></a>
Указывает именованные слоты или слоты с входными параметрами.

```html
<!-- Именованные слоты -->
<base-layout>
  <template v-slot:header>
    Содержимое заголовка
  </template>

  Содержимое слота по умолчанию

  <template v-slot:footer>
    Содержимое подвала
  </template>
</base-layout>

<!-- Именованный слот с входными параметрами -->
<infinite-scroll>
  <template v-slot:item="slotProps">
    <div class="item">
      {{ slotProps.item.text }}
    </div>
  </template>
</infinite-scroll>

<!-- Слот по умолчанию с входными параметрами, с использованием деструктурирования -->
<mouse-position v-slot="{ x, y }">
  Позиция курсора: {{ x }}, {{ y }}
</mouse-position>
```

## v-pre <a name='v-pre'></a>
Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов {{}}. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

```html
<span v-pre>{{ эта часть не будет скомпилирована }}</span>
```

## v-cloak <a name='v-cloak'></a>
Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию. В сочетании с CSS-правилом ```[v-cloak] { display: none }``` этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

```css
[v-cloak] {
  display: none;
}
```

```html
<div v-cloak>
  {{ message }}
</div>
```

## v-once <a name='v-once'></a>
Однократно отрисовывает элемент или компонент. При повторной отрисовке он, а также все его потомки, рассматриваются как статический контент и пропускаются. Это поможет увеличить производительность обновлений.

```html
<span v-once>Это никогда не изменится: {{msg}}</span>
```

[^ Вверх](#home)  


# Специальные аттрибуты <a name='spec-attr'></a>

## key <a name='key'></a>

***









[^ Вверх](#home)  
# Вычисляемые свойства <a name='computed'></a>

Вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях. 


Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его реактивных зависимостей. 

```html
<div id="demo">{{ fullName }}</div>
```

```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
computed: {
  fullName: {
    // геттер:
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // сеттер:
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
})
```
При изменении this.firstName или this.lastName будет вызван геттер.  
Запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.

# Наблюдатели <a name='watch'></a>

Эта возможность полезна для «дорогих» или асинхронных операций, выполняемых в ответ на изменение данных.
Пример использования, но в данном случае лучше использовать вычисляемые свойства.
```html
<div id="demo">{{ fullName }}</div>
```
```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

[^ Вверх](#home)  
# Стили <a name='styles'></a>

Для динамической установки или удаления CSS-классов можно передавать объект в директиву v-bind:class:   
```html
<!--  Наличие класса active будет определяться истинностью параметра isActiveю. -->
<div v-bind:class="{ active: isActive }"></div>
```
v-bind:class можно использовать совместно с обычным атрибутом class:
```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```
В v-bind:class можно передать и массив:
```html
<div v-bind:class="[activeClass, errorClass]"></div>
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```
```javascript
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

### inline-стили
Объектная запись для v-bind:style является объектом JavaScript.
```html
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
```javascript
data: {
  activeColor: 'red',
  fontSize: 30
}
```
Можно использовать и вычисляемые свойства, возвращающие объекты стилей.

[^ Вверх](#home)  
# Условная отрисовка <a name='if'></a>

> Псевдоэлемент ```<template>``` служит невидимой обёрткой и сам в результатах отрисовки не появляется.

Блок будет отображаться только в том случае, если выражение директивы возвращает значение, приводимое к true.

```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
```

**v-else**, **v-else-if** должен следовать сразу за элементом с **v-if** или **v-else-if**.

### v-show <a name='v-show'></a>

```html
<h1 v-show="ok">Привет!</h1>
```
Разница в том, что элемент с v-show будет всегда оставаться в DOM, а изменяться будет лишь свойство display в его параметрах CSS.

**v-show** не работает на элементе ```<template>``` и не работает с **v-else**.

[^ Вверх](#home)  
# Отрисовка списков <a name='for'></a>

```html
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```
```javascript
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Родитель',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```
Вместо **in** разделителем можно использовать **of**, как в итераторах JavaScript.

**v-for** можно также использовать для итерирования по свойствам объекта:  
```html
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```
Чтобы подсказать Vue, как отслеживать идентичность каждого элемента, что позволит переиспользовать и перемещать существующие элементы, необходимо указать уникальный атрибут key для каждого элемента:
```html
<div v-for="item in items" v-bind:key="item.id">
  <!-- содержимое -->
</div>
```
Из-за ограничений JavaScript, Vue не способен отследить следующие изменения в массиве:
* Прямую установку элемента по индексу: ```vm.items[indexOfItem] = newValue``` -> ```Vue.set(vm.items, indexOfItem, newValue)```
* Явное изменение длины массива: ```vm.items.length = newLength``` -> ```vm.items.splice(newLength)```
* Vue не может обнаружить добавление или удаление свойств, для добавления свойств можно использовать ```Vue.set```


[^ Вверх](#home)  
# Обработка событий <a name='event'></a>
Иногда в inline-обработчиках необходим доступ к оригинальному событию DOM. Его можно передать в метод, используя специальную переменную $event:
```html
<button v-on:click="warn('Форма не может быть отправлена.', $event)">
  Отправить
</button>
```
```javascript
// ...
methods: {
  warn: function (message, event) {
    // теперь у нас есть доступ к нативному событию
    if (event) event.preventDefault()
    alert(message)
  }
}
```
 Vue предоставляет модификаторы событий для v-on, которые указываются как постфиксы и отделяются точкой: *.stop, 
.prevent, 
.capture, 
.self, 
.once, 
.passive*.

```html
<!-- событие click не будет всплывать дальше -->
<a v-on:click.stop="doThis"></a>

<!-- событие submit больше не будет перезагружать страницу -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- модификаторы можно объединять в цепочки -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- и использовать без указания метода-обработчика -->
<form v-on:submit.prevent></form>

<!-- можно отслеживать события в режиме capture, т.е. событие, нацеленное -->
<!-- на внутренний элемент, обрабатывается здесь до обработки этим элементом -->
<div v-on:click.capture="doThis">...</div>

<!-- вызов обработчика только в случае наступления события непосредственно -->
<!-- на данном элементе (то есть не на дочернем компоненте) -->
<div v-on:click.self="doThat">...</div>
```
  
### Модификаторы клавиш
Можно использовать любые допустимые имена клавиш, предоставляемые через KeyboardEvent.key в качестве модификаторов, именуя их в kebab-case.
```html
<input v-on:keyup.page-down="onPageDown">
```

Модификатор ```.exact``` позволяет контролировать точную комбинацию системных модификаторов, необходимых для запуска события.

```html
<!-- сработает, даже если Alt или Shift также нажаты -->
<button @click.ctrl="onClick">A</button>

<!-- сработает, только когда нажат Ctrl и не нажаты никакие другие клавиши -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- сработает, только когда не нажаты никакие системные модификаторы -->
<button @click.exact="onClick">A</button>
```

### Модификаторы клавиш мыши
*.left, 
.right, 
.middle*


[^ Вверх](#home)
# Шина событий <a name='event-bus'>
Глобальный event emitter? к которому можно обратиться из любого компонента.

```javascript
Object.defineProperty(Vue.prototype,"$bus",{
	get: function() {
		return this.$root.bus;
	}
});

new Vue({
	el: '#app',
	data: {
		bus: new Vue({}) // Here we bind our event bus to our $root Vue model.
	}
});
```
Далее доступно через `this.$bus`, подписаться на событие `this.$bus.$on()`, отписаться `this.$bus.$off()`, вызвать `this.$bus.$emit()`. Не забывать отписываться от события в **beforeDestroy**. Так же можно создать <a href='https://github.com/Kasheftin/route-planner-vue/blob/master/src/utils/PromisesBus.js'>централиваную шину промисов</a>.


[^ Вверх](#home)
# Пользовательские события <a name='users-event'></a>

Всегда использовать kebab-case для имён событий.

По умолчанию ```v-model``` на компоненте использует входной параметр ```value``` и событие ```input```.

```javascript
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```
Теперь, когда используем ```v-model``` на этом компоненте:
```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```
Значение lovingVue будет передано во входном параметре checked. А обновляться свойство lovingVue будет когда ```<base-checkbox>``` сгенерирует событие change с новым значением. При этом нужно объявлять входной параметр ```checked``` в опции ```props``` компонента.

[^ Вверх](#home)
# Слоты <a name='slot'></a>
Слоты могут содержать любой код шаблона, в том числе HTML. Если шаблон компонента не содержит элемент ```<slot>```, любой переданный контент будет просто проигнорирован.

>Всё в родительском шаблоне компилируется в области видимости родительского компонента; всё в дочернем шаблоне компилируется в области видимости дочернего компонента.

Чтобы указать запасное содержимое слота (т.е. по умолчанию), которое будет отображаться только тогда, когда ничего не передавалось в слот, содержимое необходимо указать между тегами ```<slot>```.

```html
<button type="submit">
  <slot>Отправить</slot>
</button>
```

Иногда удобно иметь несколько слотов, в таких случаях элементу ```<slot>``` можно указать специальный атрибут ```name```, который используется для определения дополнительных слотов. Обычный ```<slot>``` без name неявно имеет имя **«default»**.

```html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Чтобы указать содержимое для именованного слота, нужно использовать директиву ```v-slot``` на ```<template>```, передав имя слота аргументом ```v-slot```.

```html
<base-layout>
  <template v-slot:header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <p>Параграф для основного контента.</p>
  <p>И ещё один.</p>

  <template v-slot:footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

> ```v-slot``` можно добавлять только на ```<template>```.

Так как в слоте доступны только данные родительского шаблона, т.е. отрисовываются в родительской области видимости, а иногда бывает необходимость получать данные дочернего компонента, то для этого необходимо их свяхать с помощью директивы ```v-bind```.

```html
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
```

Атрибуты, привязанные к элементу <slot>, называются **входными параметрами слота**. Теперь, в родительской области видимости, можно использовать ```v-slot``` со значением, чтобы указать имя для предоставленных слоту входных параметров:

```html
<current-user>
  <template v-slot:default="Users">
    {{ Users.user.firstName }}
  </template>
</current-user>
```

```html
<!-- НЕПРАВИЛЬНО, будет выкидывать предупреждение -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
  <template v-slot:other="otherSlotProps">
    slotProps НЕДОСТУПНЫ здесь
  </template>
</current-user>
```
При наличии нескольких слотов лучше использовать полный синтаксис на основе ```<template>``` для всех слотов.

Слоты с ограниченной областью видимости, под капотом работают заключая содержимое слота в функцию, и передавая входные параметры одним аргументом. Это значит, что значение ```v-slot``` может принимать любое допустимое выражение JavaScript, которое может появиться в позиции аргумента определения функции. Это означает, что можно использовать, например, деструктурирование (ES2015).

```javascript
function (slotProps) {
  // ... содержимое слота ...
}
```

Так же можно переименовывать входные параметры или указывать значения по умолчанию:

```html
<current-user v-slot="{ user = { firstName: 'Гость' } }">
  {{ user.firstName }}
</current-user>
```
Так же можно указывать динамечкое имя слота:

```html
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
```

Директива ```v-slot:``` так же имеет сокращенную запись, с помощью символа ```#```:

```html 
<base-layout>
  <template #header>
    <h1>Здесь мог быть заголовок страницы</h1>
  </template>

  <template #footer>
    <p>Некая контактная информация</p>
  </template>
</base-layout>
```

Но при этом эта возможность доступна только при наличии имени слота:

```html
<current-user #default="{ user }">
  {{ user.firstName }}
</current-user>
```

[^ Вверх](#home)
# Динамические и асинхронные компоненты <a name='dynamic'></a>
Для переключения компонентов испльзуется атрибут ```is```. Но в данном случае при переключении компонентов, они каждый раз перерисовываются.

```html
<component v-bind:is="currentTabComponent"></component>
```

Для того, чтобы компоненты не перерисовывались и оставили своё состояние, необходимо компонент обернуть в элемент ```<keep-alive>```:
```html
<!-- Неактивные компоненты будут закэшированы! -->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```
> Обратите внимание, что <keep-alive> требует, чтобы у всех переключаемых компонентов было задано имя, либо через опцию name компонента, либо через локальную/глобальную регистрацию.

### Асинхронные компоненты
Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и закэширует результат для дальнейшего использования.
```javascript
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Передаём определение компонента в коллбэк resolve
    resolve({
      template: '<div>Я — асинхронный!</div>'
    })
  }, 1000)
})
```
```resolve``` -  коллбэк, который вызывается после того, как определение компонента получено от сервера.    
```reject(reason)``` -можно вызвать, если загрузка не удалась.  
Так же можно вернуть ```Promise```:
```javascript
Vue.component(
  'async-webpack-example',
  // Функция `import` возвращает Promise.
  () => import('./my-async-component')
)
```
```javascript
new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
```
### Управление состоянием загрузки
Фабрика асинхронного компонента также может возвращать объект следующего формата:

```javascript
const AsyncComponent = () => ({
  // Загружаемый компонент. Значение должно быть Promise
  component: import('./MyComponent.vue'),
  // Компонент загрузки, используемый пока загружается асинхронный компонент
  loading: LoadingComponent,
  // Компонент ошибки, используемый при неудачной загрузке
  error: ErrorComponent,
  // Задержка перед показом компонента загрузки. По умолчанию: 200 мс.
  delay: 200,
  // Компонент ошибки будет отображаться, если таймаут
  // был указан и время ожидания превышено. По умолчанию: Infinity.
  timeout: 3000
})
```

[^ Вверх](#home)
# Исключения, обработка ошибок <a name='exseption'></a>

### Доступ к родительскому элементу из дочернего
В каждом дочернем компоненте экземпляра можно получить доступ к корневому экземпляру ```new Vue``` через свойство ```$root```.

```javascript
this.$root.foo // доступ к родительскому this
```
> Но! Использовать это способ нужно ак можно меньше, для этого использовать ```Vuex```.

Так же доступ к родительскому экземпляру из дочернего предоставляет свойство ```$parent```.

### Доступ к дочернему элементу из родительского 
Иногда может понадобиться в родителе из JavaScript иметь доступ к дочернему элементу, для этого можно назначить ссылочный ID дочернему компоненту с помощью атрибута ```ref```.

```html
<input ref="input">
```
```javascript
methods: {
  // Используется родителем для фокуса на input
  focus: function () {
    this.$refs.input.focus()
  }
}
```

### Внедрение зависимостей
Вместо доступов к родитльскому через ```$parent``` лучше использовать внедрение зависимотей с помощью ```provide``` и ```inject```.

Опция ```provide``` позволяет указть методы и данные, которые необходимо предоставить всем компонентам-потомкам. При этом свойства, указанные в ```provide```, не будут реактивными. 

```javascript
provide: function () {
  return {
    getMap: this.getMap
  }
}
```
Затем в дочерних компонентах для получения данных, которые указаных с помощью ```provide```, можно получить с помощью свойства ```inject```.

```javascript
inject: ['getMap']
```

### Програмное добавление прослушивателей событий

* ```$on(eventName, eventHandler)`` - прослушивать событие;   
* ```$once(eventName, eventHandler)``` - прослушивать событие только один раз;   
* ```$off(eventName, eventHandler)``` - прекращать прослушивание события.   

### Рекурсивные компоненты
Компоненты могут рекурсивно вызывать себя в своём собственном шаблоне. Они могут делать это только с помощью опции ```name```. Когда регистрируется компонент глобально с помощью ```Vue.component```, глобальный ID будет автоматически устанавливаться как параметр опции **name** компонента.

```javascript
// Этот код приведёт к ошибке «max stack size exceeded», необходимо убедиться, что рекурсивный вызов определяется по условию (т.е. используется v-if, который в конечном итоге будет false).
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

### Циклические ссылки между компонентами

Если возникает ситуация, что у компонента А в шаблоне дочерним указан компонент В, а у компонента А дочерним указан компонент В. тобы исправить это, нужно дать модульной системе точку, в которой она может сказать «A нуждается в B иногда, но нет необходимости разрешать B сначала».
```javascript
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./B.vue').default
}
```
Можно использовать асинхронный ```import``` Webpack при локальной регистрации компонента:
```javascript
components: {
  TreeFolderContents: () => import('./B.vue')
}
```

### inline-шаблоны
Если у компонента-потомка присутствует специальный атрибут ```inline-template``, то содержимое элемента будет использовано в качестве шаблона этого компонента.
```html
<my-component inline-template>
  <div>
    <p>Этот шаблон будет скомпилирован в области видимости компонента-потомка.</p>
    <p>Доступа к данным родителя нет.</p>
  </div>
</my-component>
```

### X-templates
```html
<script type="text/x-template" id="hello-world-template">
  <p>Привет, привет, привет</p>
</script>
```

```javascript
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```


### Принудительное обновление
```$forceUpdate``` позволяет использовать принудительное обновление.

### Статическое обновление
Если компонент состоит из статческого контента, то его можно выполнить один раз и закешировать, добавив директиву ```v-once``` на корневой элемент.

```javascript
Vue.component('terms-of-service', {
  template: `
    <div v-once>
      <h1>Условия использования</h1>
      ... много-много статического контента ...
    </div>
  `
})
```

[^ Вверх](#home)
# Примеси <a name='mixin'></a>
Примеси (mixins) — это гибкий инструмент повторного использования кода в компонентах Vue. Объект примеси может содержать любые опции компонентов. При использовании компонентом примеси, все опции примеси «подмешиваются» к собственным опциям компонента.

```javascript
// определяем объект примеси
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('привет из примеси!')
    }
  }
}

// определяем компонент, использующий примесь
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "привет из примеси!"
```
Если примесь и компонент содержат пересекающиеся опции, они будут определённым образом объединены.

Например, объект data претерпевает рекурсивное слияние с объектом data компонента, который имеет приоритет в случаях конфликтов.

Функции хуков с одинаковыми именами объединяются в массив, чтобы все они вызывались. Хуки примеси будут вызываться перед собственными хуками компонента.

```javascript
var mixin = {
  created: function () {
    console.log('вызван хук примеси')
  }
}

new Vue({
  mixins: [mixin],
  created: function () {
    console.log('вызван хук компонента')
  }
})

// => "вызван хук примеси"
// => "вызван хук компонента"
```

Опции, ожидающие значения в форме объектов, такие как ```methods```, ```components``` и ```directives``` будут объединены. В случае конфликта, приоритет имеют опции компонента.  

Эти же стратегии слияния используются и во ```Vue.extend()```.

Примесь может быть применена и глобально. После применения, примесь окажет влияние на все экземпляры Vue, создаваемые в дальнейшем. При правильном использовании это можно использовать для вставки логики обработки пользовательских опций.

При слиянии пользовательских опций применяется стратегия по умолчанию, которая просто заменяет одни значения другими. Если есть необходимость использовать пользовательскую логику при слиянии пользовательских опций, необходимо добавить функцию в ```Vue.config.optionMergeStrategies```.

```javascript
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // return mergedVal
}
```

Для большей части опций-объектов можно просто использовать стратегию, применяемую по умолчанию для опции ```methods```.

```javascript
var strategies = Vue.config.optionMergeStrategies;
strategies.myOption = strategies.methods;
```



[^ Вверх](#home)
# Пользовательские директивы <a name='user-directive'></a>
```javascript
// Регистрируем глобальную пользовательскую директиву `v-focus`
Vue.directive('focus', {
  // Когда привязанный элемент вставлен в DOM...
  inserted: function (el) {
    // Переключаем фокус на элемент
    el.focus()
  }
})
```
Чтобы зарегистрировать директиву локально, можно передать опцию directives при определении компонента.
```javascript
directives: {
  focus: {
    // определение директивы
    inserted: function (el) {
      el.focus()
    }
  }
}
```
```html
<input v-focus>
```

### Хуки жизненного цикла

* **bind** - вызывается однократно, при первичном связывании директивы с элементом. Здесь можно поместить код инициализации.

* **inserted** - вызывается после вставки связанного элемента внутрь элемента родителя.

* **update** - вызывается после обновления VNode компонента-контейнера, но, возможно, до обновления дочерних элементов. Значение директивы к этому моменту может измениться.

* **componentUpdated** - вызывается после обновления как VNode компонента-контейнера, так и VNode его потомков.

* **unbind** - вызывается однократно, при отвязывании директивы от элемента.

В хуки передаются следующие параметры:

* **el** - Элемент, к которому привязана директива, используется для прямых манипуляций с DOM.
* **binding** - Объект, содержащий следующие свойства:  
  + **name** - Название директивы, без указания префикса v-.  
  + **value** - Значение, переданное в директиву. Например, для v-my-directive="1 + 1" значением будет 2.  
  + **oldValue** - Предыдущее переданное в директиву значение. Доступно только для хуков ```update``` и  ```componentUpdated```, и передаётся независимо от того, произошло ли в действительности его изменение.   
  + **expression** Выражение-строка, переданное в директиву. Например, для ```v-my-directive="1 + 1"``` это будет "1 + 1".  
  + **arg** - Аргумент, переданный в директиву, в случае его наличия. Например, для ```v-my-directive:foo``` это будет "foo".  
  + **modifiers** - Объект, содержащий модификаторы, если они есть. Например, для ```v-my-directive.foo.bar```, объектом модификаторов будет ```{ foo: true, bar: true }```.  
* **vnode** - Виртуальный элемент, созданный компилятором Vue.   
* **oldVnode** - Предыдущий виртуальный элемент, доступный только для хуков ```update``` и ```componentUpdated```.

Все аргументы, кроме ```el```, следует понимать как только для чтения и никогда не изменять их. В случае необходимости передать информацию между хуками рекомендуем воспользоваться ```dataset```.

```html
<div id="hook-arguments-example" v-demo:foo.a.b="message"></div>
```
```javascript
Vue.directive('demo', {
  bind: function (el, binding, vnode) {
    var s = JSON.stringify
    el.innerHTML =
      'name: '       + s(binding.name) + '<br>' +           //'demo'
      'value: '      + s(binding.value) + '<br>' +          //'привет!'
      'expression: ' + s(binding.expression) + '<br>' +     //'message' 
      'argument: '   + s(binding.arg) + '<br>' +            //'foo'
      'modifiers: '  + s(binding.modifiers) + '<br>' +      //{'a':true, 'b': true}
      'vnode keys: ' + Object.keys(vnode).join(', ')        //tag, data, children, text, elm, ns,       context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder
  }
})

new Vue({
  el: '#hook-arguments-example',
  data: {
    message: 'привет!'
  }
})

```

### Динамические аргументы директивы

Аргументы директивы могут быть динамическими. ```argument``` может обновляться в зависимости от свойства данных экземпляра компонента
```v-mydirective:[argument]="value"```

```html
<div id="dynamicexample">
  <h3>Прокрутите страницу вниз</h3>
  <p v-pin:[direction]="200">Элемент зафиксирован в 200px слева страницы.</p>
</div
```
```javascript
Vue.directive('pin', {
  bind: function (el, binding, vnode) {
    el.style.position = 'fixed'
    var s = (binding.arg == 'left' ? 'left' : 'top')
    el.style[s] = binding.value + 'px'
  }
});

new Vue({
  el: '#dynamicexample',
  data: function () {
    return {
      direction: 'left'
    }
  }
});
```


[^ Вверх](#home)
# Render-функции и JSX <a name='render-jsx'></a>
**render-функции** — это более низкоуровневая альтернатива шаблонам.

Аргументом render-функции является альтернатива строковым шаблонам - функция **CreateElement**.

```javascript
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // Название тега HTML, опции компонента или асинхронная функция,
  // возвращающая один из двух них. Обязательный параметр.
  'div',

  // {Object}
  // Объект данных, содержащий атрибуты,
  // который указывался в шаблоне. Опциональный параметр.
  {
        {
  // То же API, что и у `v-bind:class`, принимающий
  // строку, объект, массив строк или массив объектов
  class: {
    foo: true,
    bar: false
  },
  // То же API, что и у `v-bind:style`, принимающий
  // строку, объект, массив строк или массив объектов
  style: {
    color: 'red',
    fontSize: '14px'
  },
  // Обычные атрибуты HTML
  attrs: {
    id: 'foo'
  },
  // Входные параметры компонентов
  props: {
    myProp: 'bar'
  },
  // Свойства DOM
  domProps: {
    innerHTML: 'baz'
  },
  // Обработчики событий располагаются под ключом `on`,
  // однако модификаторы, вроде как `v-on:keyup.enter`, не
  // поддерживаются. Проверять keyCode придётся вручную.
  on: {
    click: this.clickHandler
  },
  // Только для компонентов. Позволяет слушать нативные события,
  // а не генерируемые в компоненте через `vm.$emit`.
  nativeOn: {
    click: this.nativeClickHandler
  },
  // Пользовательские директивы. Обратите внимание, что `oldValue`
  // не может быть указано, так как Vue сам его отслеживает
  directives: [
    {
      name: 'my-custom-directive',
      value: '2',
      expression: '1 + 1',
      arg: 'foo',
      modifiers: {
        bar: true
      }
    }
  ],
  // Слоты с ограниченной областью видимости в формате
  // { name: props => VNode | Array<VNode> }
  scopedSlots: {
    default: props => createElement('span', props.text)
  },
  // Имя слота, если этот компонент
  // является потомком другого компонента
  slot: 'name-of-slot',
  // Прочие специальные свойства верхнего уровня
  key: 'myKey',
  ref: 'myRef',
  // Если указываете одно имя в ref к нескольким элементам
  // в render-функции — это сделает `$refs.myRef` массивом
  refInFor: true
}

  },

  // {String | Array}
  // Дочерние виртуальные узлы (VNode), создаваемые с помощью `createElement()`
  // или просто строки для получения 'текстовых VNode'. Опциональный параметр.
  [
    'Какой-то текст прежде всех остальных элементов.',
    createElement('h1', 'Заголовок'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
```

Все виртуальные узлы в компоненте должны быть уникальными. Т.е., напрмиер, дочерние узлы указывать не в массиве:
```javascript
createElement('div', [
    // дублирующиеся виртуальные узлы!
    myParagraphVNode, myParagraphVNode
  ]);

// альткрнатива
  Array.apply(null, { length: 20 }).map(function () {
      return createElement('p', 'Привет')
    });
```

### v-model
```javascript
props: ['value'],
render: function (createElement) {
  var self = this
  return createElement('input', {
    domProps: {
      value: self.value
    },
    on: {
      input: function (event) {
        self.$emit('input', event.target.value)
      }
    }
  })
}
```

Для модификаторов событий **.passive**, **.capture** и **.once**, Vue предоставляет префиксы, которые могут быть использованы вместе с **on**:
**.passive:**	&  
**.capture:**	!  
**.once:**	~  
**.capture.once или .once.capture:** ~!    
Для модификаторов клавиш префиксов нет.


Чтобы получить статическое содержимое лотов, используется ```this.$slots```.  
Чтобы получить доступ к слотам со своей областью видимости как к функциям, возвращающим VNode, используя ```this.$scopedSlots```.
Чтобы передать слот со своей областью видимости:
```javascript
    createElement('child', {
      // передаём `scopedSlots` в объект data
      // в виде { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {
          return createElement('span', props.text)
        }
      }
    });
```

[^ Вверх](#home)  
# Функциональный компонент <a name='functional'></a>
Это компонент, у которого отсутствует состояние (нет реактивных данных) и экземпляр (нет переменной контекста this).

```javascript
Vue.component('my-component', {
  functional: true,
  // входные параметры опциональны
  props: {
    // ...
  },
  // чтобы компенсировать отсутствие экземпляра
  // передаётся контекст вторым аргументом
  render: function (createElement, context) {
    // ...
  }
})
```

Всё необходимое компоненту передаётся через context — объект, содержащий следующие поля:

**props** - Объект со всеми переданными входными параметрами.  
**children** - Массив дочерних виртуальных узлов.  
**slots** - Функция, возвращающая объект со слотами.  
**scopedSlots** - Объект, содержащий все переданные слоты с ограниченной областью видимости. Также предоставляет доступ к обычным слотам в качестве функций.  
**data** - Объект данных целиком, переданный объекту вторым аргументом createElement.  
**parent** - Ссылка на родительский компонент.  
**listeners** - Объект, содержащий все зарегистрированные в родителе прослушиватели событий. Это просто псевдоним для data.on.  
**injections** - Если используется опция inject, будет содержать все разрешённые инъекции.

[^ Вверх](#home)  
# Плагины <a name='plugins'></a>
Для использования плагина необходимо вызвать глобальный метод **Vue.use()**. Его нужно вызывать перед new Vue():
```javascript
Vue.use(MyPlugin, { someOption: true })
```
Создание плагина:
```javascript
MyPlugin.install = function (Vue, options) {
  // 1. добавление глобального метода или свойства
  Vue.myGlobalMethod = function () {
    // некоторая логика ...
  }

  // 2. добавление глобального объекта
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // некоторая логика ...
    }
    ...
  })

  // 3. добавление опций компонентов
  Vue.mixin({
    created: function () {
      // некоторая логика ...
    }
    ...
  })

  // 4. добавление метода экземпляра
  Vue.prototype.$myMethod = function (methodOptions) {
    // некоторая логика ...
  }
}
```

[^ Вверх](#home) 
# Фильтры <a name='filters'></a>
Применяются в mustache-интерполяциях и в выражениях v-bind. Фильтры добавляются в конце выражения JavaScript и отделяются вертикальной чертой:
```javascript
filters: {  // {{ message | capitalize }}
  capitalize: function (value) {
   return value;
  }
}
// либо
Vue.filter('capitalize', function (value) {
  return value;
});

// цепочки фильтров
{{ message | filterA | filterB }}

// передача аргументов
{{ message | filterA('arg1', arg2) }}

```

[^ Вверх](#home) 
# Vuex <a name='vuex'></a>
Хранилище данных, которые могут изменяться только предсказуемым образом.  

```javascript
import Vuex from 'vuex';

const store = new Vuex.Store({
  state: {},    // корневой объект состояния хранилища
  
  mutations: { 
    someMutation (state, preload) { ... }, // Аргументы:   состояние и нагрзука (если есть)
    ...
  },

  actions: {
    someAction (contex, preload) { ... },
    ...
  },

  getters: {
    someGetter (state, getters) { ... }, // В модуле аргументы (state, getters, rootState, rootGetters) - логальное состояние и геттеры и глобальное состояние и геттеры
    ...
  },

  modules: { // содержит подмодули, работают с локальными состояниями
    key: {
      state,
      namespaced,
      mutations,
      actions,
      getters,
      modules
    },
    ...
  },

  plugins: [], // Плагины получают хранилище в качестве единственного аргумента, 
               // и могут как отслеживать мутации (для сохранения исходящих данных, логирования или отладки)
               // или инициировать их (для обработки входящих данных, например, websockets или observables)

  strict: true/false, // любые изменения состояния, происходящие вне обработчиков мутаций, будут выбрасывать ошибки

  devtools: true/false, // Интеграция в devtools конкретного экземпляра Vuex             

});
```

Доступ можно получить через ```store.state, store.mutations``` и т.д.

**commit(type: string [, payload: any, options: Object]) или (mutation: Object[, options: Object])** - запускает мутицию. ```root: true``` в опциях запускает корневые мутации.  
**dispatch(type: string [, payload: any, options: Object]) или (action: Object [, options: Object])** - запускает действия, возвращает промис. ```root: true``` в опциях запускает корневые действия.  
**replaceState(state: Object)** - замена корневого состояния хранилища новым.  
**watch(fn: Function, callback: Function [, options: Object]): Function** - отслеживает возвращаемое значение fn, и вызывает коллбэк в случае изменений. Первым аргументом fn будет состояние хранилища, вторым — геттеры.  
**subscribe(handler: Function): Function** - обработчик handler вызывается после каждой мутации и получает в качестве параметров дескриптор мутации и состояние после мутации. 




[^ Вверх](#home)
# Vue-router <a name='vue-router'>
Создание экземпляра объекта маршрутизатора:  
```javascript
Vue.use(VueRouter);

const router = new VueRouter({
    mode: 'history', //указывает режим навигации
    routes
});
```
Предварительно необходимо создать роуты, где пути сопоставляются с компонентами:
```javascript
const routes = [
  { path: '/',
    name: 'home',  // именованный маршрут, далее можно обращаться <router-link :to="{ name: 'user', params: { userId: 123 }}">
    component: Home // компонент через Vue.extend() либо объект с опциями компонента
    alias: '/b' // т.е. при переходе по адресу /b отрендерится компонент Home
  }, 
  { path: '/about', 
    redirect: { name: 'home' }, // перенаправление, можно указать строку или объект с описанием маршрута
    component: About,
    props: true // Когда props установлено в значение true, значения route.params будут устанавливаться входными параметрами компонента. Когда props объект, они будут устанавливаться входными параметрами компонента. 
    },
  { path: '*', 
    component: NotFound 
    } // сопоставляется по всем
];
```
В текущем шаблоне использовать компонент `<router-view></router-view>`, куда будет помещаться соответствующий компонент.

Доступен через `this.$router`, `this.$route` - текущий маршрут.
Динамическая часть в роуте указывается через `:`, например, `{ path: '/user/:id', component: User }`, само значение доступно через `this.$route.params`, если параметр необязательный, то в конце ставится `?` ('/user/:id?').  

`$route.path` - абсолютный путь текущего маршрута;  
`$route.params` - пары ключ-значение динамических частей пути (`this.$route.params.pathMatch` - часть под звездочкой);  
`$route.query` - параметры запроса;  
`$route.hash` - хеш текущего маршрута (#);  
`$route.fullPath` - полный url;  
`$route.matched` - массив маршрутов;  
`$route.name` - имя текущего маршрута;  
`$route.redirectedFrom` - имямаршрута, с которого произошло перенаправление.

Для использования вложенных путей (*/user/sora/profile*, *user/sora/posts*) используется опция `children`:  
```javascript
const router = new VueRouter({
  routes: [
    { path: '/user/:id', component: User,
      children: [
        {
          path: 'profile',
          component: UserProfile // user/sora/profile
        },
        {
          path: 'posts',
          component: UserPosts // user/sora/posts
        },
         { path: '', 
           component: UserHome // user/sora
         }
      ]
    }
  ]
})
```

Для перехода по новому url с добавление в историю:
```javascript
  router.push(location, onComplete?, onAbort?); // аналогично <router-link :to="..."> и window.history.pushState

  router.push({ path: 'home' })
  router.push({ name: 'user', params: { userId: '123' } })
  router.push({ path: 'register', query: { plan: 'private' } })
```

Для перехода без добавления в историю:
```javascript
router.replace(location, onComplete?, onAbort?); // аналогично <router-link :to="..." replace> и  window.history.replaceState
```

Перейти по истории на какое-то кол-во шагов:
```javascript
router.go(n); // аналогично window.history.go(n)
```

### Именованное представление
```html
<router-view class="view one"></router-view>
<router-view class="view two" name="a"></router-view>
<router-view class="view three" name="b"></router-view>
```
```javascript
  const router = new VueRouter({
    routes: [
      {
        path: '/',
        components: {
          default: Foo,
          a: Bar,
          b: Baz
        }
      }
    ]
  })
```



### Хуки 




# Vue-cli <a name='cli'></a>


[^ Вверх](#home)
# Тестирование <a name='test'></a>





[^ Вверх](#home) 
# vue-class-component <a name='vue-class-component'></a>
```
npm install --save vue vue-class-component
```
Либо сразу при создание проекта через vue-cli (```vue create my-app```), указать TypeScript и на вопрос, использовать ли class-style component - yes. 