1. **Single Responsibility Principle (SRP)** (принцип единственной ответственности). Модуль может иметь одну и только одну причину для изменения.

Улучшает архитектуру, уменьшает время разработки, уменьшает кол-во ошибок.

Пример:  
Если есть какая-то функция для отправки запросов на бек, то она не должна обрабатывать ошибки, в нее можно прокинуть коллбек, который будет вызван при возникновении ошибок, либо просто прокинуть ошибку дальше.

2. **The Open/Closed Principle (OCP)** (принцип открытости/закрытости). Классы и другие элементы должны быть открыты для расширения, но закрыты для модификации.

Обычно достигается с помощью наследования и полиморфизма. Создание простых абстрогированных от данных компонентов, которые закрыты для модификации, от которых можно наследоваться.

Для фронта:
Создание абстрогированных от данных компонентов.  
Компонентная композиция с использованием свойства children. HOC.

3. **The Liskov Substitution Principle (LSP)** (принцип подстановки Лисков). Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Классы-наследники должны сохранять поведение и контракты классов-родителей. Не изменять сигнатуры методов при переопределении.

4. **The Interface Segregation Principle (ISP)**  (принцип разделения интерфейса). Программные сущности не должны зависеть от методов, которые они не используют.

Если интерфейс содержит слишком много методов, то клиенты, которым не нужны некоторые методы, будут вынуждены реализовывать их все равно. Лучше разбить этот интерфейс на несколько меньших интерфейсов с енобходимыми методами.

5. **The Dependency Inversion Principle (DIP)** (принцип инверсии зависимостей). Модули верхних уровней не должны зависеть от модулей нижних уровней.

Высокоуровневые и низкоуровневые модули должны зависеть от абстракций. Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

Уменьшает связанность между модулями. Легко можно заменить реализацию одного компонента без влияния на другие компоненты. Облегчает тестирование, подключение моков. Так как компоненты системы становятся более абстрактными, то их проще переиспользовать.

Достигается часто с помощью шаблонов проектирования "Абстрактная фабрика" и "Стратегия".
